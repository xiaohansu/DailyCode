# DAY 03

> ## About: `Echart xAxis使用'time'作为横轴`

> ## Language: `js`

> ## Content:

````js
//data_time的格式:[[timestamp,value],[timestamp,value]...],like:
//data:[[12345674,1],[123456548,8]...]
//xAxis type: 'time',不需要添加数值
option = {
                tooltip : {
                    trigger: 'axis',
                    axisPointer: {
                        type: 'cross',
                        label: {
                            backgroundColor: '#6a7985'
                        }
                    }
                },
                dataZoom: [
                    {
                        show: true,
                        realtime: true,
                        start: 0,
                        end: 100
                    },
                    {
                        type: 'inside',
                        realtime: true,
                        start: 0,
                        end: 100
                    }
                ],
                title: {
                    text: '拍照路点RTK状态',
                    subtext: '1为FIXED_POINT',
                    x: 'center',
                },
                xAxis: {
                    type: 'time',//不需要添加其他
                },
                yAxis: {
                    type: 'value',
                    max:2
                },
                series: [{
                    /////
                    data: data_time,//
                    /////
                    type: 'line',
                    markPoint: {
                        data: markList
                    }
                }]
            };
````

> ## About:  `图片转base64`

> ## Language: `node js`

> ## Content:

```js
function compress_base64(image){
    const images  = require('images');
    return 'data:image/jpeg;base64,' + images(image)
        .resize(300)
        .encode("jpg", {operation:50})
        .toString('base64');
}
```

 **关于electron使用`images`模块的问题：**

由于electron配置的`node js`版本问题，`images`模块在当electron在 `windown64`的系统环境下运行，不支持。



> ## About: `python 迭代器和生成器`

> ## Language: `python`

> ## Content:

 *迭代器？*

对象实现了`__iter__`和`__next__`的方法对象都可以称为迭代器

 *生成器？*

python中**特殊的迭代器**，多特殊? 只有一个值 

generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次被next（）调用时候从上次的返回yield语句处急需执行，也就是用多少，取多少，不占内存。



```python
# 斐波拉契数列
def fib(max):
    n,a,b = 0,0,1
    while n < max:
        yield b
        a,b = b,a+b
        n = n + 1 
    return 'done'
for i in fib(5):
    print(i)

'''
1
1
2
3
5
'''
```

**生成器使用`for in `进行遍历**



---



# DAY 05

> ## About: `python 装饰器`

> ## Language: `python`

> ## Content:



装饰器，用于装饰函数方法，在调用某个函数时，先做某些处理逻辑。

```python
def printer(func):
    def inner():#装饰函数
        print '装饰内容。。。'
        func()#被装饰的函数
    return inner#装饰完函数

def sayHello():
    print 'hello'

@printer
sayHello()


'''
装饰内容。。。
hello
'''

```



- xx：公有变量
- _xx：单前置下划线，私有化属性或方法，类对象和子类可以访问，**from somemodule import *禁止导入**
- __xx：双前置下划线，私有化属性或方法，无法在外部直接访问（名字重整所以访问不到）
- __ xx __：双前后下划线，系统定义名字（不要自己发明这样的名字）
- xx_：单后置下划线，用于避免与Python关键词的冲突



> ### 常用的内置装饰器

### **@property**

使用该装饰器装饰的方法，可以像类的属性一样访问，可以实现类似面向对象的set&get方法

```python
class TestClass:
    def __init__(self, name):
        self.__name = name
    
    # get name
    @property
    def name(self):
        return self.__name
    # set name
    @name.setter
    def name(self,name):
        self.__name = name

    @staticmethod
    def sayHello(self):
        print('hi')

t = TestClass('lili')
t.name = 'huahua'
print(t.name)
    
# huahua

TestClass.sayHello(None)

# hi
```

### @staticmethod

将类中的方法装饰为静态方法，即类不需要创建实例的情况下，可以通过类名直接引用。到达将函数功能与实例解绑的效果。



### @classmethod

类方法的第一个参数是一个类，是将类本身作为操作的方法。类方法被哪个类调用，就传入哪个类作为第一个参数进行操作。

# coding: utf-8
```python
class Car(object):
    car = "audi"
    @classmethod
    def value(self, category): # 可定义多个参数，但第一个参数为类本身
        print "%s car of %s" % (category, self.car)


class BMW(Car):
    car = "BMW"

class Benz(Car):
    car = "Benz"

print "通过实例调用"
baoma = BMW()
baoma.value("Normal") # 由于第一个参数为类本身，调用时传入的参数对应的时category

print "通过类名直接调用"
Benz.value("SUV")
```





> ## About: `GIL: Global Interpreter Lock`

> ## Language: `python`

> ## Content:

**全局解释器锁**





